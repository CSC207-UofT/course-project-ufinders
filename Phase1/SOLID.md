Single Responsibility Principle: User_Controls only focuses on user input, Searcher only makes searches, Sorter only sorts, and the various comparators and filters only make their own very specific distinctions (ex. Is this item from a given campus).  
Each class of the journal section has a single responsibility. For example, JournalUI’s responsibility is to take input from the user, like what they want to do in the journal, and carry out that action. The JournalWindow’s responsibility is presenting what the user wants to see in a pop-up window. The JournalController’s responsibility is to delegate to JournalManager, which delegates to FileGateway and Journal. FileGateway’s responsibility is creating files, deleting files, and editing files. Lastly, the journal’s responsibility is to store a mapping of the entry title to file with the entry and get information about what it stores.

Open-Closed Principle: Filters can easily be extended without needing to modify existing filters or the existing searcher. The same is true for comparators and sorters in the Marketplace.
Because we are worried that there would be too many classes, we decided not to make ItemManager a parent class where its subclasses can extend from ItemManager and create their own type of objects. Additionally, we decided not to make ItemManager a parent class because all the subclasses would have the same single responsibility.

Liskov Substitution Principle:
Interface Segregation Principle: The Filter interface has a single method which is necessary for all filters to implement, so there is no need for this interface to be further segregated. The interface segregation principle is also used within the FileGateway Interface. This interface only has three methods that class implementing has to implement. FileGateway is an interface that is used to interact with files such as create files, delete files and get information from files.

Dependency Inversion Principle: User_Controls knows nothing about how items are created, only the information it needs to pass down to ItemManager or Searcher. (User_Controls does, however, depend on the current Filter, Searcher, and Sorter implementation in order to pass down information to them, although It does not know how they use said information). Similarly, Searcher does not depend on filters or sorters beyond their output. None of the classes I worked on rely on a certain implementation of Item, as long as the types and get functions remain consistent where necessary.  
The dependency inversion principle is also used in the journal section. For example, JournalFileGateway is a gateway class, and a use case, JournalManager wants to delegate to JournalFileGateway, which will result in a violation of clean architecture. So I used an interface, FileGateway, to invert the dependency and allow JournalManager to delegate to FileGateway indirectly.
