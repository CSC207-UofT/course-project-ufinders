Our classes all fall into the different layers of clean architecture. Searcher, sorter, and the comparators and filters are all use cases, manipulating items based on directives from User_Controls (without knowing how those directives came about or how their output will be used). Similarly, User_Controls takes in and distributes user information, without knowing how that user information will actually be used. Because we are currently using a command line interface, User_Controls acts as both a controller and a UI, but those uses will be split into two classes if we move to a GUI. The ItemManager is the use case layer which depends on the Database to get the information from. The Database, which is the entity, knows nothing about the ItemManager and its only job is to get information on items stored and store items and its only rule is to be of Item type. The ItemManager manages all the data that goes to and from the entity. The journal section of the program also adheres to clean architecture. The dependency between the layer of clean architecture within the journal program is inward. For example,  JournalUI(UI) depends on the JournalWindow(presenter)  and JournalController(controller) which depends on the JournalManager(use case) which depends on the FileGateway(interface) Journal (entity). Regarding events, The events code is split into four layers to mirror the four layer structure of clean architecture. There is EventUI, a class that represents the direct input from the frontend/user, like adding events, deleting events, turning on alarms for events, entering keywords, etc. The next layer is EventManager, the controller class which takes the inputs from the EventUI and distributes commands accordingly, whether to MakeDeleteEvent (a Use Case) to make or delete an event, or to GetEvent (another Use Case) to get a list of events from the UofT website. Both use cases also refer to the Event entity, as they construct events and then return them to the EventUI class for delivery to the frontend.


