Our classes all fall into the different layers of clean architecture, with dependency going inward. MarketplaceUI (UI) depends on MarketplaceWindow (presenter) and MarketplaceController (controller). The controller depends on use cases including Searcher, Sorter, and the comparators and filters, which manipulate  Items (entities). Items depend on nothing. Similarly, the ItemManager is a use case which depends on the Database to get information. The Database, which is an entity, knows nothing about the ItemManager--its only job is to get information on Items stored and store Items. The ItemManager manages all the data that goes to and from the entity.

The journal section of the program also adheres to clean architecture. The dependency between the layer of clean architecture within the journal program is inward. For example,  JournalUI(UI) depends on the JournalWindow(presenter)  and JournalController(controller) which depends on the JournalManager(use case) which depends on the FileGateway(interface) Journal (entity).


Regarding events, The events code is split into four layers to mirror the four layer structure of clean architecture. There is EventUI, a class that represents the direct input from the frontend/user, like adding events, deleting events, turning on alarms for events, entering keywords, etc. The next layer is EventManager, the controller class which takes the inputs from the EventUI and distributes commands accordingly, whether to MakeDeleteEvent (a Use Case) to make or delete an event, or to GetEvent (another Use Case) to get a list of events from the UofT website. Both use cases also refer to the Event entity, as they construct events and then return them to the EventUI class for delivery to the frontend.
